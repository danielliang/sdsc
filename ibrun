#!/usr/bin/env perl
################################################################################
# ibrun - SDSC's re-implementation of the ibrun wrapper for the various MPI
#         launchers
#
# Glenn K. Lockwood, San Diego Supercomputer Center             December 2013
################################################################################

use strict;
use warnings;
use Sys::Hostname;
use Getopt::Long;
use POSIX;

use constant CONTACT => 'Contact help@xsede.org for additional assistance.';
use constant ENABLE_DEBUGGING => 1;

my $options; 

### Hacks for MVAPICH2
$ENV{MV2_USE_UD_HYBRID} = 0 unless $ENV{MV2_USE_UD_HYBRID};
$ENV{MV2_USE_OLD_BCAST} = 1 unless $ENV{MV2_USE_OLD_BCAST};
$ENV{MV2_HOMOGENEOUS_CLUSTER} = 0 unless $ENV{MV2_HOMOGENEOUS_CLUSTER};
$ENV{MV2_USE_HUGEPAGES} = 0 unless $ENV{MV2_USE_HUGEPAGES};

### Pull in default options from the resource manager
$options->{sys_rm}      = 'Torque';
$options->{rm_nodefile} = $ENV{PBS_NODEFILE};
$options->{rm_num_nodes}= $ENV{PBS_NUM_NODES};
$options->{rm_ppn}      = $ENV{PBS_NUM_PPN};
$options->{rm_jobid}    = $ENV{PBS_JOBID};
$options->{mpi_srq_size}        = 2048;
$options->{mpi_default_timeout} = 23;
$options->{rm_num_ranks}   = $options->{rm_num_nodes} * $options->{rm_ppn};

### Machine-specific stuff
{
    my $hostname = hostname();
    if ( $hostname =~ m/^(gcn-|gordon-)/ ) { 
        $options->{sys_ppn}         = 16;
        $options->{sys_max_nodes}   = 128;
    }
    elsif ( $hostname =~ m/^trestles-/ ) {
        $options->{sys_ppn}         = 32;
        $options->{sys_max_nodes}   = 32;
    }
    elsif ( $hostname =~ m/^tscc-/ ) {
        $options->{sys_ppn}         = 16;
        $options->{sys_max_nodes}   = 9999999;
    }
}

### Let command-line options override 
$options = get_options( \@ARGV, $options );
$options->{cmd} = shift(@ARGV);
$options->{cmd_args} = \@ARGV;

### Determine MPI stack to be used
$options->{mpi_stack} = "mvapich2";
$options->{mpi_launcher} = "mpirun_rsh";

### Load nodelist into an array
my $nodelist = load_nodefile( $options->{rm_nodefile} );

### Build the nodefile for this MPI job
if ( $options->{nodefile_offset} && $options->{nodefile_offset} > 0 )
{
    # ...construct a truncated and offset nodefile
    bailout( 1, "This feature is not yet available.\n" );
}
elsif ( ($options->{num_nodes} * $options->{npernode}) == ($options->{rm_num_nodes} * $options->{rm_ppn}) )
{
    dprintf("no hostfile mod needed\n");
    $options->{nodefile} = $options->{rm_nodefile};
}
else
{
    dprintf(sprintf("hostfile hacking needed: %d\n", $options->{npernode} ));
    $options->{nodefile} = 
        gen_hybrid_nodefile( $nodelist, $options );
}

my $run_string = 'echo "A terrible error has occurred.  ' . CONTACT . '" >&2';
if ( $options->{mpi_stack} eq "mvapich2" )
{
    if ( $options->{mpi_launcher} eq 'mpirun_rsh' )
    {
        $run_string = "mpirun_rsh -np %d -hostfile %s %s";
    }
    elsif ( $options->{mpi_launcher} eq 'mpiexec.hydra' )
    {
        $run_string = "mpiexec.hydra -np %d -hostfile %s %s";
    }
    else
    {
        bailout( 2, "Unknown/undefined MPI launcher\n" );
    }
}
elsif ( $options->{mpi_stack} eq "openmpi" )
{
    bailout( 1, "This feature is not yet available.\n" )
}
elsif ( $options->{mpi_stack} eq "mpich2" )
{
    bailout( 1, "This feature is not yet available.\n" )
}
else
{
    bailout(2, sprintf( "Unknown MPI stack '%s'.  %s\n",
        ($options->{mpi_stack} ? $options->{mpi_stack} : "????"), CONTACT) );
}


my $cmd_string = sprintf( $run_string,
    $options->{num_ranks},          # number of MPI ranks
    $options->{nodefile},           # nodefile location
    "",                             # other mpirun parameters
    $options->{cmd},                # command itself
);

#unlink($options->{nodefile});           # delete the nodefile
printf( "Nodefile is %s\n", $options->{nodefile} );
printf( "Command string is [%s] with args [%s]\n", $cmd_string, join(' ', @{$options->{cmd_args}}) );
#system( $cmd_string, @{$options->{cmd_args}} );

################################################################################
### Subroutines
################################################################################

### Load nodelist from nodefile into an array and return it
sub load_nodefile
{
    my $nodefile = shift;
    open (NODEFILE, $nodefile) or bailout( 1, "Unable to open nodefile $nodefile\n");

    my @nodelist;
    
    while ( my $line = <NODEFILE> )
    {
        $line =~ m/^\s*(\S+)\s*$/;
        push( @nodelist, $1 );
    }
    return \@nodelist;
}

### Rebuild a nodefile based on user input, return its location
sub gen_hybrid_nodefile
{
    use File::Temp;
    my $nodelist = shift;
    my $options = shift;
    
    my ($fh, $filename) = File::Temp::tempfile();

    my $npernode = $options->{npernode};
    my @my_npernode;

    #### Convert nodelist into a list of unique nodes with order preserved
    my @unique_nodes;
    foreach my $node ( @$nodelist ) {
        push( @unique_nodes, $node ) unless grep {$_ eq $node} @unique_nodes;
    }

    ### Make sure the nodelist contains the same number of nodes as the 
    ### resource manager says it should contain
    if ( scalar(@unique_nodes) != $options->{rm_num_nodes} ) {
        bailout( -5, sprintf( "ERROR: assert failed: #nodes (%d) in nodefile "
            ."(%s) inconsistent with nodecount (%d) from %s\n",
            scalar(@unique_nodes),
            $options->{rm_nodefile},
            $options->{rm_num_nodes} ) );
    }

    ### Make sure the user isn't requesting more nodes that he or she was given
    if ( scalar(@unique_nodes) < $options->{num_nodes} )
    {
        close($fh);
        unlink($filename);
        bailout( 4, 
            sprintf("ERROR: Your MPI job requested %d nodes but %s only provided %d.\n",
            $options->{num_nodes}, $options->{sys_rm}, scalar(@unique_nodes) ) );
    }

    # -N supercedes the number of nodes given by the batch system
    my $nodes_to_use = $options->{num_nodes};

    # Positive npernode means npernode divides evenly into num_nodes.  Just 
    # print $npernode copies per node into the new nodefile.
    if ( $npernode > 0 )
    {
        @my_npernode = ($npernode) x $options->{num_nodes};
    }
    # Negative npernode means npernode does not divide evenly into num_nodes
    elsif ( $npernode < 0 )
    {
        dprintf( "hacking hostfile...\n" );
        $npernode = abs($npernode);
        @my_npernode = ($npernode) x $options->{num_nodes};
        my $num_ranks = $options->{num_ranks};
        my $num_nodes = $options->{num_nodes};
        
        # figure out which nodes need to take up the slack
        dprintf( "remainder is %d = %d - %d * %d\n", 
            ($num_ranks - $num_nodes * $npernode),
            $num_ranks,
            $num_nodes,
            $npernode );
        foreach my $i ( 0 .. ($options->{num_nodes}-1) )
        {
            $my_npernode[$i]++ if $i < ($num_ranks - $num_nodes * $npernode);
        }
    }

    ### Convert our nodelist and my_npernode into nodefiles
    dprintf("Got %d unique nodes\n", $nodes_to_use);
    foreach my $i ( 0 .. ($nodes_to_use-1) )
    {
        printf "got %d ranks on node %d\n", $my_npernode[$i], $i;
        foreach ( 1 .. $my_npernode[$i] )
        {
            print $fh $unique_nodes[$i] . "\n";
        }
    }
    close($fh);

    return $filename;
}

### Parse command line input and check for errors.  This will be called
### AFTER the resource manager's paramaters have already been loaded into
### the options hash.
sub get_options
{
    my $argv = shift;
    my $old_options = shift;
    my %new_options;
    use Getopt::Long;
    Getopt::Long::Configure( "require_order", "no_ignore_case", 
                            "auto_version", "auto_help", "no_auto_abbrev" );
    if ( @$argv > 0 ) 
    {
        GetOptions(
            "o=i"           =>  \$new_options{nodefile_offset},
            "no=i"          =>  \$new_options{node_offset},
            "N=i"           =>  \$new_options{num_nodes},
            "n|np=i"        =>  \$new_options{num_ranks}, 
            "npernode=i"    =>  \$new_options{npernode},
        );
    }

    ### Check the consistency of user-provided options before doing anything
    #
    # Hybrid jobs (those which do not run one MPI rank per core) can be 
    # specified in several ways:
    #
    #   1. Specifying -N and -n (a la Slurm)
    #   2. Specifying -N and -npernode (a la OpenMPI)
    #   3. Just -n (let the RM pick up the -N)
    #   4. Just -npernode (let the RM pick up the -N)
    #
    #   Thus, if neither -npernode nor -n are provided, this is not a hybrid 
    # job.  In all cases, rm_num_ranks should probably be ignored.  As long as
    # we can gaurantee that num_nodes and npernode are defined by the end of
    # get_options(), we can calculate num_ranks.
    #
    #   In the event that npernode is negative (i.e., not all nodes have the
    # same loading due to num_ranks%npernode != 0), num_ranks is already 
    # defined by the user so it would be safe to carry that value forward
    # without recalculating.
    #
    if ( $new_options{num_ranks}
    &&   $new_options{num_nodes}
    &&   $new_options{npernode}
    &&   ($new_options{num_nodes}*$new_options{npernode}) != $new_options{num_ranks} ) {
        bailout( 1, "ERROR: Either provide -N and -n OR -N and --npernode\n" );
    }
    if ( $new_options{npernode}
    &&   $new_options{num_ranks} )
    {
        bailout( 1, "ERROR: Either provide -n OR --npernode, but not both\n" );
    }

    # Check offset arguments to maintain compatibility with TACC's ibrun 
    # implementation.  Also added a per-node offset
    if ( $new_options{nodefile_offset}
    && ( ($new_options{num_ranks} && $new_options{nodefile_offset} >= $new_options{num_ranks})
    ||   $new_options{nodefile_offset} < 0) ) {
        bailout( 1, "ERROR: Your nodefile offset (-o) must be between 0 and (n-1).\n" );
    }
    if ( $new_options{node_offset}
    && ( ( $new_options{num_nodes}
    &&   $new_options{node_offset} >= $new_options{num_nodes})
    ||   $new_options{node_offset} < 0 ) ) {
        bailout( 1, "ERROR: Your node offset (-no) must be between 0 and (N-1).\n" );
    }

    # Make sure user did not entire anything that is numerically nonsensical
    if ( $new_options{num_nodes} && $new_options{num_nodes} <= 0 ) {
        bailout( 1, "ERROR: Your number of nodes (-N) must be greater than zero.\n" );
    }
    if ( $new_options{num_ranks} && $new_options{num_ranks} <= 0 ) {
        bailout( 1, "ERROR: Your number of ranks (-n) must be greater than zero.\n" );
    }
    if ( $new_options{npernode} && $new_options{npernode} <= 0 ) {
        bailout( 1, "ERROR: Your ranks per node (--npernode) must be greater than zero.\n" );
    }


    # Merge in the user-provided values with the pre-set values.  Overwrite old
    # pre-set values with user-provided when duplicates occur.
    my %options = ( %$old_options, %new_options );


    ### If user did not specify certain parameters, copy the values from what
    ### the resource manager (rm) provided
    # this job should skip the first X entries in the nodefile
    if ( !$options{nodefile_offset} ) { 
        dprintf( "Using default nodefile_offset...\n" );
        $options{nodefile_offset} = 0; 
    }

    # this job should skip the first X unique nodes in the nodefile
    if ( !$options{node_offset} ) {
        dprintf( "Using default node_offset...\n" );
        $options{node_offset} = 0;
    }

    # how many nodes the job will use
    if ( !$options{num_nodes} ) {
        dprintf( "Using default num_nodes...\n" );
        $options{num_nodes} = $options{rm_num_nodes}
    }

    # how many MPI ranks total the job will use
    if ( !$options{num_ranks} ) {
        dprintf( "Using default num_ranks...\n" );
        $options{num_ranks} = $options{rm_num_ranks};
    }

    # how many MPI ranks per node the job will use.  If this is NEGATIVE, then 
    # the division is uneven and the node breakdown requires a lot more logic,
    # so flag the npernode parameter and let gen_hostfile() do that
    my $remainder = $options{num_ranks} % $options{num_nodes};
    if ( !$options{npernode} )
    {
        dprintf( "Calculating proper npernode since -npernode wasn't defined...\n" );
        if ( $remainder == 0 ) {
            $options{npernode} = $options{num_ranks} / $options{num_nodes};
        }
        else {
            $options{npernode} = -1 * floor($options{num_ranks} 
                                    / $options{num_nodes});
        }
    }
    elsif ( $remainder != 0 ) {
        dprintf( "Calculating proper npernode due to uneven division of numranks/numnodes...\n" );
        $options{npernode} = -1 * floor($options{num_ranks} 
                                / $options{num_nodes});
    }
    # recalculate num_ranks in case user specified -N which is less than 
    # rm_num_nodes.  if npernode is negative though, leave it alone since
    # an imbalance of ranks per node can only occur if the user specified
    # num_ranks explicitly already
    $options{num_ranks} = $options{num_nodes} * $options{npernode} if $options{npernode} > 0;

    ### Check the sanity of the inputted parameters
    if ( $options{npernode} > $options{sys_ppn} ) 
    {
        # don't bail here; some codes have a lightweight management rank that 
        # in addition to the one-rank-per-core compute ranks
        printf( STDERR 
            "WARNING: Your job will put more ranks on each node (%d) than the "
            ."cores physically available to each node (%d)\n",
            $options{npernode}, $options{sys_ppn} );
    }

    if ( $options{num_nodes} > $options{sys_max_nodes} )
    {
        bailout(3, sprintf("ERROR: Your job requests more nodes (%d) than the "
            ."maximum allowed per job (%d)\n",
            $options{num_nodes},
            $options{sys_max_nodes} ) );
    }

    ### at this point, num_ranks, num_nodes, and npernode are guaranteed to 
    ### exist and be well-defined at this point
    return \%options;
}

sub bailout
{
    my $errno = shift;
    my $errmsg = shift;
    print STDERR $errmsg;
    exit $errno;
}

sub dprintf
{
    return unless ENABLE_DEBUGGING;
    printf( @_ );
}

__END__

=pod

=head1 NAME

ibrun - launch MPI jobs from an implementation-independent command

=head1 DESCRIPTION

This application launches an MPI job using a simple user interface that automatically configures the implementation- and system-specific features on whichever MPI stack the user wants to use.

-n, -np <n>
    launch n MPI ranks (default: use all cores provided by resource manager)

-o, --offset <n>
    assign MPI ranks starting at the nth slot provided by the resource manager
    (default: 0)

--npernode <n>
    only launch n MPI ranks per node

-h 
    print this message

=head1 KNOWN BUGS

No known issues.

=head1 AUTHOR

Glenn K. Lockwood (glock@sdsc.edu)

=cut
